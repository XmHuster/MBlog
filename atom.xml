<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HappyBird</title>
  <subtitle>No fear and Go ahead</subtitle>
  <link href="/MBlog/atom.xml" rel="self"/>
  
  <link href="https://xmhuster.github.io/MBlog/"/>
  <updated>2017-09-02T03:03:16.818Z</updated>
  <id>https://xmhuster.github.io/MBlog/</id>
  
  <author>
    <name>xie mei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>变长编码二元化</title>
    <link href="https://xmhuster.github.io/MBlog/2017/08/31/%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81/"/>
    <id>https://xmhuster.github.io/MBlog/2017/08/31/变长编码/</id>
    <published>2017-08-31T06:06:29.683Z</published>
    <updated>2017-09-02T03:03:16.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变长编码"><a href="#变长编码" class="headerlink" title="变长编码"></a>变长编码</h4><p>在视频编码当中，有存在很多的冗余，各种方法的设计都是为了消除这些冗余，从而在压缩程度上达到最好。</p>
<p>在编码过程中，如果我们要编码的数的范围时从0到7，那么0和1只需要一个比特就可以表示，7需要三个比特，那么我们都统一用三个比特进行表示的话。那么小的数就会浪费一些比特。</p>
<p>所以在这种情况下，我们就出现了变长编码。也就出现了一些生成变长码的方法，这里只说明其中比较重要的两个，哥伦布编码（EGK）和截断莱斯（TR）。</p>
<h4 id="K阶哥伦布编码"><a href="#K阶哥伦布编码" class="headerlink" title="K阶哥伦布编码"></a>K阶哥伦布编码</h4><p>一个非负整数的K阶哥伦布码的生成步骤：</p>
<p>1、将需要编码的整数以二进制的形式写出，去掉最低的K个比特位，之后加1。</p>
<p>2、统计剩下的比特数，将次数减一，就是需要增加的前缀零的个数。</p>
<p>3、把之前去掉的K个比特位补回到比特串的末尾。</p>
<p>现在举个例子说明，比如说整数5的1阶码：</p>
<p>1、5的二进制形式时 101，那么去掉最低1位的比特位，就变成10，之后再加1，就是11。<br>2、11就是2个比特数，把2减一就是1，也就是需要补1个前缀0，那么现在的比特就变成011。<br>3、把之前去掉的最低1位的1补回到比特串的结尾，就变成0111，这就是整数5的1阶哥伦布码。</p>
<p>编码完，我们现在要知道怎么解码。<br>解码原理：根部编码的时候，我们知道第一步去掉k个比特，第三步的时候补上了，所以这k个比特的值是没有改变的，就是在第一步的最后，我们还加了一个1，那么我们在解码的时候就是要将这个1减掉。那么因为第三步又加了k个比特，就相当于第一步的那个1，是2^k的大小，所以就是把所有的值减去2^k,就是解码会来的值。<br>例如：<br>上面的整数5的2阶码为 01001，那么这个二进制的值为9-2^2 = 5。<br>或者按照书中的codeNum = 2^(m+k)-2^k+value(这个值为后m+k个二进制的值)也是一样的。</p>
<p>接着，我们用代码实现一下。</p>
<p>编码的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    int value = 5;//这个就是需要编码的值</div><div class="line">    int pre = (value &gt;&gt; k)+1;//这个实现的就是第一步。</div><div class="line">    int m = (int)log2(pre);//获取前面的0的个数，之前还不知道怎么取，</div><div class="line">//还用一个变量右移然后求出个数。也就是第二步。</div><div class="line">    int last = value - ((value&gt;&gt;k)&lt;&lt;k);//求出右移k的比特，因为之后要加到比特串后面。</div><div class="line">    pre = pre &lt;&lt; (32 - (2*m+1));//把前半部分比特移动最左边，我们之后好一个一个取出来传输。</div><div class="line">    int res = pre | (last&lt;&lt;(32-(2*m+k+1)));//这个就是最后要编码的值。也就是0111 后面还有很多零。</div><div class="line">    unsigned int mark = 0x80000000;//这边一定要用无符号，不然的话有符号，右移的话会根据符号进行填充左边的值，而不是填充0。</div><div class="line">    for(int i = 0; i &lt; 2*m+k+1; i++)&#123;</div><div class="line">        int bit = !!(mark &amp; res);//取出每一个bit。</div><div class="line">        printf(&quot;%d\t&quot;,bit);</div><div class="line">        put_cabac_bypass(enc_context.cabac_context,bit);</div><div class="line">        mark &gt;&gt;= 1;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>解码的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int value = 0;</div><div class="line">   int m = 0;</div><div class="line">   int k = 1;</div><div class="line">   while(get_cabac_bypass(dec_context.cabac_context) == 0)&#123;</div><div class="line">       m++;//知道前面有多少个零。</div><div class="line">   &#125;</div><div class="line">   for(int i = 0; i &lt; m+k; i++)&#123;</div><div class="line">       value = (value &lt;&lt; 1) + get_cabac_bypass(dec_context.cabac_context);//求出后面的值。</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   int res = ((1&lt;&lt;(m+k))-(1&lt;&lt;k)+value);//根据之前的公式求出最后的值。</div></pre></td></tr></table></figure>
<p>这个指数哥伦布还有有符号的时候，对应的关系是：</p>
<p>CodeNum =  {2V-1, V &gt; 0; -2V , V &lt;= 0}</p>
<p>CodeNum及其对应的有符号数的V</p>
<table>
<thead>
<tr>
<th style="text-align:center">CodeNum</th>
<th style="text-align:center">V</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">-2</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">-3</td>
</tr>
</tbody>
</table>
<h4 id="截断莱斯编码"><a href="#截断莱斯编码" class="headerlink" title="截断莱斯编码"></a>截断莱斯编码</h4><p>一个非负整数截断莱斯码的生成步骤：</p>
<p>在已知门限值cMax，和莱斯参数R,已经需要编码的值V，就可以获得截断莱斯的二元码串。截断莱斯码分为前缀和后缀。</p>
<p>1、前缀的计算方法为： P = V &gt;&gt; R;</p>
<p>2、 若P&lt;(cMac&gt;&gt;R),则前缀由P个1和一个0组成，长度为P+1。若P &gt;= (cMac&gt;&gt;R)，则由（cMax&gt;&gt;R）个1组成，长度为（cMac&gt;&gt;R）。</p>
<p>2、当V<cmax时，其后缀值为s =="" v="" -="" （p="" <<r）。后缀码为s的二元化串，长度为r。当v="">=cMax的时候没有后缀值。</cmax时，其后缀值为s></p>
<p>PS: 其实当R设置为0的时候，也就是让它没有后缀码。</p>
<p>在代码实现之前，我们可以把截断莱斯码列出来看一下。</p>
<p>cMax = 6, r = 1</p>
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:center">prefix</th>
<th style="text-align:center">suffix</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">10</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">110</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">110</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center">111</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>同样，我们代码实现一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int value = i;</div><div class="line">int r = 1;</div><div class="line">int cMax = 6;</div><div class="line">int p = value &gt;&gt; r;//这个实现的就是第一步。</div><div class="line">int pre = 0;</div><div class="line">int res = 0;</div><div class="line">unsigned int mark = 0x80000000;</div><div class="line">if((value&gt;&gt;r) &lt; (cMax&gt;&gt;r))&#123;</div><div class="line">    if(p)&#123;</div><div class="line">        pre = 0xffffffff &lt;&lt; (32-p);</div><div class="line">    &#125;</div><div class="line">    int s = value-(p&lt;&lt;r);</div><div class="line">    res = pre | s &lt;&lt;(32-r-p-1);</div><div class="line">    for(int i = 0; i &lt; p+1+r; i++)&#123;</div><div class="line">        int bit = !!(mark &amp; res);</div><div class="line">        put_cabac_bypass(enc_context.cabac_context,bit);</div><div class="line">        mark &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">&#125;else&#123;</div><div class="line">    res = 0xffffffff &lt;&lt;(32-(cMax&gt;&gt;r));</div><div class="line">    for(int i = 0; i &lt; (cMax&gt;&gt;r); i++)&#123;</div><div class="line">        int bit = !!(mark &amp; res);</div><div class="line">        put_cabac_bypass(enc_context.cabac_context,bit);</div><div class="line">        mark &gt;&gt;= 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解码代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">int value = 0;</div><div class="line">      int r = 1;</div><div class="line">      int cMax = 6;</div><div class="line">      int p = 0;</div><div class="line">      int t = cMax &gt;&gt; r;</div><div class="line">      while(get_cabac_bypass(dec_context.cabac_context) == 1 &amp;&amp; p &lt; t)&#123;</div><div class="line">          p++;</div><div class="line">      &#125;</div><div class="line">      if(p &gt;= t)&#123;</div><div class="line">          value = cMax;</div><div class="line">      &#125;else&#123;</div><div class="line">          int suf = 0;</div><div class="line">          for(int i = 0; i &lt; r; i++)&#123;</div><div class="line">              suf = (suf &lt;&lt; 1) + get_cabac_bypass(dec_context.cabac_context);</div><div class="line">          &#125;</div><div class="line">          value = (p&lt;&lt;r) + suf;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>通过上面的分析，我们会发现，这个cMax的值和莱斯参数R不是随便设置都可以的。<br>我们知道，当R = 0和 Value = cMax的这两种情况是没有后缀码的。</p>
<p>但是如果cMax = 7 ，R = 1。那么当Value = 6的时候的前缀码等于Value = 7的前缀码，但是一个有后缀，一个无后缀，我们在解码的时候就没有办法确定。所以cMax = 7,R = 1。这种设置就是不合理的。</p>
<p>所以截断莱斯还会配合着指数哥伦布使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;变长编码&quot;&gt;&lt;a href=&quot;#变长编码&quot; class=&quot;headerlink&quot; title=&quot;变长编码&quot;&gt;&lt;/a&gt;变长编码&lt;/h4&gt;&lt;p&gt;在视频编码当中，有存在很多的冗余，各种方法的设计都是为了消除这些冗余，从而在压缩程度上达到最好。&lt;/p&gt;
&lt;p&gt;在编码过程中
    
    </summary>
    
      <category term="2017年9月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="视频编码" scheme="https://xmhuster.github.io/MBlog/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>碰到问题的时候该怎么处理</title>
    <link href="https://xmhuster.github.io/MBlog/2017/08/26/%E7%A2%B0%E5%88%B0%E9%97%AE%E9%A2%98%E8%AF%A5%E6%9C%89%E7%9A%84%E6%80%81%E5%BA%A6/"/>
    <id>https://xmhuster.github.io/MBlog/2017/08/26/碰到问题该有的态度/</id>
    <published>2017-08-26T04:02:21.547Z</published>
    <updated>2017-08-26T07:13:30.421Z</updated>
    
    <content type="html"><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>程序员遇到问题，遇到Bug这是在所能免的事情，当大一大二刚遇到问题的时候，那个时候可能是卖卖萌，求学长帮忙解决一下。幸好，当时碰到的几个学长都是授之以渔的，所以慢慢的就通过搜索引擎开始解决问题了。大三的时候基本上都遇到问题都是自己解决了。刚开始肯定是比较抓狂的，问题很难解决的时候是比较绝望的，这个时候如果解决了问题，所收获的成就感也是满满的。<br>等习惯了之后，碰到问题也不会绝望了，因为自信也是在慢慢中建立的，相信所有的问题都是可以被解决的。</p>
<h4 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h4><p>在过往的程序开发当中，遇到的问题可以简单的分为10种。<br>一种是在编译器上面可以调试的，这个问题一般都是比较简单的，因为通过调试就可以找到错误，并且修改。<br>另外一种就是可以是在装一个软件的过程种出错了，或者是报了结果不是自己想要的。比如说之前的IE插件开发，需要在显示栏显示我的图标，然后程序编译没有错误，但是显示栏就是没有我的图标等之类的问题就比较复杂一些了。</p>
<h4 id="问题应对"><a href="#问题应对" class="headerlink" title="问题应对"></a>问题应对</h4><ul>
<li>第一种编译问题，语法，逻辑错误的话都是很简单的错误。只要调试一下就可以了。</li>
<li>第二种问题。需要冷静分析，从头理顺思路，排除各种可能出现的错误原因。</li>
<li><p>理解原理，得原理算法者得天下。（会有这种的感受是因为：现在工作在的公司，旁边好几个博士生，其中一个博士生就对我们所做的原理非常的清楚，所以当你问他问题的时候，你就会发现，虽然他在编程代码上可能不是非常了解，但是从原理的角度上一下子就可以看出代码是否有问题，这样子行不行。）</p>
</li>
<li><p>今天春招面试A家的时候，面试官问平时都是怎么解决问题的。因为没有反应过来，很长一段时间也没有敲代码了，就想到最近写的IE插件开发，因为之前从来没有接触过，时间也比较短，所以就只能按照官方文档来，正如上面说的，因为对原理和一些配置代码什么的都不是很清楚，所以当时因为一个地方写错了，就不是很清楚，只能一直不断的尝试。所以我当时就回答说，我重复的尝试。 其实找问题最好的肯定不是说一直不分析的不断重复的尝试，而是要分析问题，然后不断的排错，找原因的。</p>
</li>
</ul>
<h4 id="避免问题"><a href="#避免问题" class="headerlink" title="避免问题"></a>避免问题</h4><p>写代码的时候就尽量做到每一个地方细节都很清楚，而不是大概知道干什么，或者有的干什么也不是很清楚。这样子会比较不容易出问题，或者等出了问题，也可以比较快的知道哪里出了问题，出了什么问题。</p>
<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>写这篇文章是为了记录下来自己现在的想法（如果能有其他人看到我的文章，并且从中受益，那当然是最好不过的了），因为谁都不敢保证自己之后是否能按照现在的想法执行，或者说之后因为一些事情就会忘记了现在的想法。所以内容并不是非常的丰富，但是我还是选择记录下来。并且我觉得记录下自己当下的想法，所做的事情，所遇到的问题，是一个非常好的习惯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h4&gt;&lt;p&gt;程序员遇到问题，遇到Bug这是在所能免的事情，当大一大二刚遇到问题的时候，那个时候可能是卖卖萌，求学长帮忙解决一下。幸好，当时碰到的几个学长
    
    </summary>
    
      <category term="2017年8月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="其他" scheme="https://xmhuster.github.io/MBlog/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>全局变量在不同的文件中是否会多次初始化的问题。</title>
    <link href="https://xmhuster.github.io/MBlog/2017/08/16/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E5%A4%9A%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://xmhuster.github.io/MBlog/2017/08/16/全局变量是否会多次初始化的问题/</id>
    <published>2017-08-16T00:20:53.371Z</published>
    <updated>2017-08-28T06:45:14.626Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="2017年8月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="c/c++" scheme="https://xmhuster.github.io/MBlog/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>熵编码</title>
    <link href="https://xmhuster.github.io/MBlog/2017/08/11/%E7%86%B5%E7%BC%96%E7%A0%81/"/>
    <id>https://xmhuster.github.io/MBlog/2017/08/11/熵编码/</id>
    <published>2017-08-11T08:35:43.663Z</published>
    <updated>2017-08-31T03:47:44.948Z</updated>
    
    <content type="html"><![CDATA[<h4 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h4><p>1、什么是熵编码？<br>熵编码就是指按信息熵原理进行的无损编码方式，无损编码也是有损编码视频编码中一个关键的模块，它处于视频压缩系统的末端。熵编码把一系列用来表示视频序列的元素符号转变成一个用来传输或存储的压缩码流，输入的符号可能包括量化系数，运动矢量信息，预测模式信息等。熵编码可以有效的去除这些视频元素符号的统计冗余，是保证视频熵编码效率的重要工具。</p>
<p>2、那么什么是信息熵？<br>我们平时所说的消息是信息吗？<br>信息是存在于消息之后，消息中可以消除不确定因素的部分可以称之为信息。香农给出的信息的定义是：信息是事物运动状态或存在方式的不确定性的描述。<br>那么信息是否可以度量呢？<br>信息是可以度量的。因为不确定性是可以度量的。所以信息也是可以度量的。<br>不确定性越大，那么信息量就越大，反之，就越小。</p>
<p>比如：我明天会穿着运动服去打球。<br>这一句话就可以消除几个不确定性，我明天穿什么衣服呢？穿运动服。我明天去干什么呢？去打球。所以这句话就是存在着信息。</p>
<p>再比如：鞋子穿久了会破掉。 鞋子穿久了肯定会破的。所以这一句话没有消除任何不确定性，所以这句话没有任何信息量。所以这也就是我们说的废话。</p>
<p>假设某一信源的概率空间为[( x,p(x)] = [(x1,p(x1)), (x2,p(x2)), … , (xq ,p(xq)],且他们的概率之和为1。其中p(x<em>i</em>)就是信源发出符号x<em>i</em>的概率。那么，输出一个信源符号x<em>i</em>时，其信息量定位为 I(x<em>i</em>) = log(1/p(x<em>i</em>)。I(x<em>i</em>)通常被称为信源符号x<em>i</em>的自信息，表明该符号出现的不确定性。</p>
<p>因为信源中有很多不同的符号，所以一个符号的自信息是不能表明整个信源的信息量的。所以就出现了信息熵。‘<br>我们定义自信息的数学期望为信源的信息熵:H(X) = E[log(1/p(x<em>i</em>))],这个值也就是等于-p(x<em>i</em>)log(1/p(x<em>i</em>))从1到q的和。</p>
<p>这样子，我们就知道了两个概念自信息和信息熵用来表示信息量。</p>
<p>针对信息熵就是利用到概率的前提下，我们知道概率有可能有条件概率等问题。<br>下面给出三个概念：联合熵，条件熵，极限熵。<br>联合熵 H<em>N</em>(X)= H(X<em>1</em>,X<em>2</em>,X<em>3</em>…X<em>N</em>);<br>条件熵 H(X<em>N</em>|X<em>1</em>X<em>2</em>..X<em>N-1</em>)</p>
<ul>
<li><p>当N趋于无穷大的时候，联合熵的均值和条件熵的值都存在且相等，这个极值就被称为极限熵。 </p>
</li>
<li><p>当N给定时，他们的关系时 条件熵&lt;= 联合熵的均值 &lt;= H<em>1</em>(x)。</p>
</li>
</ul>
<p>以上表明，在信源输出序列中符号之间的前后依赖关系越长，前面若干个符号发生后，其后发生什么符号的不确定性就变弱。也就是说，条件较多的熵要比条件较少的熵小。如果依赖关系无限长，联合熵的均值和条件熵都会非递增的趋向于极限熵。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;熵编码&quot;&gt;&lt;a href=&quot;#熵编码&quot; class=&quot;headerlink&quot; title=&quot;熵编码&quot;&gt;&lt;/a&gt;熵编码&lt;/h4&gt;&lt;p&gt;1、什么是熵编码？&lt;br&gt;熵编码就是指按信息熵原理进行的无损编码方式，无损编码也是有损编码视频编码中一个关键的模块，它处于视频压缩系
    
    </summary>
    
      <category term="2017年8月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="视频编码" scheme="https://xmhuster.github.io/MBlog/tags/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>kSum问题汇总</title>
    <link href="https://xmhuster.github.io/MBlog/2017/07/20/Ksum%E9%97%AE%E9%A2%98/"/>
    <id>https://xmhuster.github.io/MBlog/2017/07/20/Ksum问题/</id>
    <published>2017-07-20T14:03:18.472Z</published>
    <updated>2017-08-26T07:13:02.747Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode上面有一系列的kSum问题，这里对kSum进行一个总结。</p>
<h4 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="external">Two Sum</a></h4><p>题目：<br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<p>题目分析：一开始考虑说排序，然后再从两头向中间靠拢，就可以求出答案了。但是后来发现这题是要求输出下标，而不是数它本身，所以排序的方法就行不通了。所以就考虑使用haspMap的方式。</p>
<p>解法一:<br>步骤一：先把整个数组进行排序，然后从两端缩进，看想加的和是否为目标数，这个是最常规的想法。这题由于是要输出下标而不是数值本身，所以还要遍历一遍数组找到对应的下标。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(nums.size() == 0)&#123;</div><div class="line">            return res;</div><div class="line">        &#125;</div><div class="line">        vector&lt;int&gt; temp;</div><div class="line">        temp = nums;</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        int len = nums.size();</div><div class="line">        int start = 0;</div><div class="line">        int end = len - 1;</div><div class="line">        while(start &lt; end)&#123;</div><div class="line">            if(nums[start] + nums[end] == target)&#123;</div><div class="line">                for(int i = 0; i &lt; temp.size(); i++)&#123;</div><div class="line">                    if(temp[i] == nums[start] || temp[i] == nums[end])&#123;</div><div class="line">                        res.push_back(i);</div><div class="line">                        if(res.size() == 2) break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;else if(nums[start] + nums[end] &lt; target)&#123;</div><div class="line">                start++;</div><div class="line">            &#125;else&#123;</div><div class="line">                end--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>解法二：<br>步骤一： 先把所有的数都加入到map当中，因为数组中有重复的数存在，所以就没有办法让map中对应的值为它的下标，到时候直接取出来就行。而是让它的值加一。<br>步骤二：通过一个循环，把当前数对应的map值减一，然后再调用map判断这个值是否存在，并且它的值是否大于０，如果都满足，则说明找到了答案。<br>步骤三： 这个时候需要根据我们找到的那个答案的值，然后去找对应的下标。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        if(nums.size() == 0)&#123;</div><div class="line">            return res;</div><div class="line">        &#125;</div><div class="line">        map&lt;int,int&gt; m;</div><div class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</div><div class="line">            if(m.find(nums[i]) != m.end())&#123;</div><div class="line">                m[nums[i]]++;</div><div class="line">            &#125;else&#123;</div><div class="line">                m[nums[i]] = 1;</div><div class="line">            &#125;</div><div class="line">        &#125;//把所有的值都放到map里面去。</div><div class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</div><div class="line">            int left = target - nums[i];</div><div class="line">            m[nums[i]]--;</div><div class="line">			//使用完一次就减一。下面再判断是否大于0，这样子可以防止[3,3]</div><div class="line">            if(m.find(left) != m.end() &amp;&amp; m[left] &gt; 0)&#123;</div><div class="line">                res.push_back(i);</div><div class="line">                for(int j = i+1; j &lt; nums.size(); j++)&#123;</div><div class="line">                    if(nums[j] == left)&#123;</div><div class="line">                        res.push_back(j);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>解法三：<br>看了讨论就会发现同样是用hashmap，但是人家的运行时间可以更快，快了3ms。</p>
<p>直接遍历，如果目标值减去当前值并没有存在map中的时候，就直接把这个值加到map当中，然后map中这个值对应的值就是它的下标。如果找到就直接返回就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        map&lt;int,int&gt; m;</div><div class="line">        for(int i = 0; i &lt; nums.size(); i++)&#123;</div><div class="line">            int left = target - nums[i];</div><div class="line">            if(m.find(left) != m.end())&#123;</div><div class="line">                res.push_back(m[left]);</div><div class="line">                res.push_back(i);</div><div class="line">                return res;</div><div class="line">            &#125;</div><div class="line">            m[nums[i]] = i;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode上面有一系列的kSum问题，这里对kSum进行一个总结。&lt;/p&gt;
&lt;h4 id=&quot;Two-Sum&quot;&gt;&lt;a href=&quot;#Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;Two Sum&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leet
    
    </summary>
    
      <category term="2017年8月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="Leetcode" scheme="https://xmhuster.github.io/MBlog/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://xmhuster.github.io/MBlog/2017/07/20/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://xmhuster.github.io/MBlog/2017/07/20/git学习/</id>
    <published>2017-07-20T10:10:37.184Z</published>
    <updated>2017-08-14T13:55:09.692Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Git的学习"><a href="#关于Git的学习" class="headerlink" title="关于Git的学习"></a>关于Git的学习</h4><p>  这里我转载一个廖雪峰老师的博客<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰官方网站</a>，这篇博客基本命令还有原理都解释的很清楚，内容不多也不少，非常适合初学者阅读学习。</p>
<h4 id="关于Git的一些补充"><a href="#关于Git的一些补充" class="headerlink" title="关于Git的一些补充"></a>关于Git的一些补充</h4><ol>
<li>怎么推送本地的分支到远程的新分支上面去？<br>添加：git push origin local_branch:remote_branch<br>这个操作，local_branch必须为你本地存在的分支，remote_branch为远程分支，如果remote_branch不存在则会自动创建分支。<br>删除：git push origin :remote_branch，local_branch留空的话则是删除远程remote_branch分支。</li>
</ol>
<h4 id="关于Git出现的错误"><a href="#关于Git出现的错误" class="headerlink" title="关于Git出现的错误"></a>关于Git出现的错误</h4><p>Q1: 当输入git pull时，出现以下错误。<br>ssh: Could not resolve hostname git.tucodec.com: Name or service not known<br>fatal: Could not read from remote repository.</p>
<p>Please make sure you have the correct access rights<br>and the repository exists.</p>
<p>A: 这种连不上的情况，其实就是网络不好，或者时使用了VPN,然后VPN出现了问题，检查一下就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于Git的学习&quot;&gt;&lt;a href=&quot;#关于Git的学习&quot; class=&quot;headerlink&quot; title=&quot;关于Git的学习&quot;&gt;&lt;/a&gt;关于Git的学习&lt;/h4&gt;&lt;p&gt;  这里我转载一个廖雪峰老师的博客&lt;a href=&quot;https://www.liaoxuef
    
    </summary>
    
      <category term="2017年8月" scheme="https://xmhuster.github.io/MBlog/categories/2017%E5%B9%B48%E6%9C%88/"/>
    
    
      <category term="git" scheme="https://xmhuster.github.io/MBlog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>怎么使用hexo在github上面搭建个人博客</title>
    <link href="https://xmhuster.github.io/MBlog/2016/09/04/hello-world/"/>
    <id>https://xmhuster.github.io/MBlog/2016/09/04/hello-world/</id>
    <published>2016-09-04T10:47:13.158Z</published>
    <updated>2017-07-15T08:33:27.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>本篇博客是记录自己怎么搭建起这个博客，以及过程中遇到什么问题，如何解决这些问题。</p>
<h2 id="了解Hexo"><a href="#了解Hexo" class="headerlink" title="了解Hexo"></a>了解Hexo</h2><ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">hexo</a></li>
</ul>
<h2 id="安装GIT"><a href="#安装GIT" class="headerlink" title="安装GIT"></a>安装GIT</h2><ul>
<li><a href="https://desktop.github.com/" target="_blank" rel="external">GitHub Windows</a></li>
</ul>
<h2 id="安装Node-JS"><a href="#安装Node-JS" class="headerlink" title="安装Node.JS"></a>安装Node.JS</h2><ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.JS</a></li>
</ul>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在安装完GIT后，桌面上会出现Git Shell，打开后，输入npm命令就可以安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div><div class="line">$ npm install hexo --save</div></pre></td></tr></table></figure></p>
<h2 id="hexo的配置"><a href="#hexo的配置" class="headerlink" title="hexo的配置"></a>hexo的配置</h2><p> 根据自己的习惯，选择把hexo配置在哪里（比如：C:\OTHER\Program\GitHub\hexo），通过Git Shell,切换到该路径下面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure></p>
<p>或者可以<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;floder&gt;</div><div class="line">$ <span class="built_in">cd</span> &lt;floder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<h2 id="安装hexo插件"><a href="#安装hexo插件" class="headerlink" title="安装hexo插件"></a>安装hexo插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-index --save</div><div class="line">npm install hexo-generator-archive --save</div><div class="line">npm install hexo-generator-category --save</div><div class="line">npm install hexo-generator-tag --save</div><div class="line">npm install hexo-server --save</div><div class="line">npm install hexo-deployer-git --save</div><div class="line">npm install hexo-deployer-heroku --save</div><div class="line">npm install hexo-deployer-rsync --save</div><div class="line">npm install hexo-deployer-openshift --save</div><div class="line">npm install hexo-renderer-marked@0.2 --save</div><div class="line">npm install hexo-renderer-stylus@0.2 --save</div><div class="line">npm install hexo-generator-feed@1 --save</div><div class="line">npm install hexo-generator-sitemap@1 --save</div></pre></td></tr></table></figure>
<h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<h2 id="部署到github上面"><a href="#部署到github上面" class="headerlink" title="部署到github上面"></a>部署到github上面</h2><ol>
<li>申请一个github账号（怎么创建仓库，以及使用可以阅读官网文档<a href="https://guides.github.com/activities/hello-world/" target="_blank" rel="external">GitHub</a>）</li>
<li>打开之前下载安装在桌面的Github，点击左上角的+，自己取一个名字，然后把Local Path选择自己习惯的位置（比如：C:\OTHER\Program\GitHub\MBlog），个人放在hexo的旁边。</li>
<li>git Shell回到hexo文件夹下执行hexo g命令，会生成一个Public文件夹。<br>PS:<br>$ hexo g == hexo generate（生成静态文件）<br>$ hexo s == hexo server（启动服务器）<br>$ hexo d == hexo deploy(部署到github上面。)</li>
<li>把public文件夹里面的东西拷贝到之前Local Path的根目录下面。</li>
<li>在桌面Github上面确定提交信息后，点又上角的syn同步</li>
<li>可以到网页的Github中心查看，并且知道自己的网址（比如：<a href="https://xmhuster.github.io/MBlog/">https://xmhuster.github.io/MBlog/</a></li>
<li>这样就发布完成了</li>
</ol>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>hexo提供了很多<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>可以供选择，主题点击进去都有模板可以参考修改，官网也有很好的文档。</p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>怎么写文章呢，这里是用<a href="http://markdownpad.com/" target="_blank" rel="external">Markdown</a>，语法真的非常简单，只要看一下就能使用。<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="external">参考文档</a><br>注意：Markdown目前还不支持Win10，但是解决办法肯定还是有的。如果是Win10系统需要下载安装一下<a href="http://www.awesomium.com/" target="_blank" rel="external">awesomium</a></p>
<h2 id="怎么使用Disqus安装评论"><a href="#怎么使用Disqus安装评论" class="headerlink" title="怎么使用Disqus安装评论"></a>怎么使用Disqus安装评论</h2><p>1.首先到Disqus官网注册一下。<br>2.GetStart-&gt;I want to install Disqus on my site-&gt;create a new site(填写一些名称和自己的网站地址)-&gt;save。这样子就完成了并且生成了一个shortname。<br>3.在hexo目录下的config.yml里面配置一下。我的版本是有这个disqus_shortname: 之前把之前的shortname写上去就可以了。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Q：为什么本地的Localhost:4000页面能很好的显示主题，但是发布到Github上面却显示不了，没有渲染成功？<br>A：有几种可能性：<br>1，_config.yml里面的url没有配置好。<br>2.没有安装主题所需要的插件,下面是hexo官方原话，大家可以在themes文件夹里面主题文件夹（比如说:jacman）的Layout里面可以看到是以Swig结尾的还是Ejs结尾的，如果是EJS结尾的需要另外安装插件。(具体可以点击下面的EJS查看)</p>
<blockquote>
<p>Layout folder. This folder contains the theme’s template files, which define the appearance of your website. Hexo provides the Swig template engine by default, but you can easily install additional plugins to support alternative engines such as <a href="https://github.com/hexojs/hexo-renderer-ejs" target="_blank" rel="external">EJS</a>, Haml or Jade. Hexo chooses the template engine based on the file extension of the template. </p>
</blockquote>
<p>3.在网页版的Github上面，需要建分支，合并提交等。（不清楚的看官方文档）</p>
<h2 id="总结感悟"><a href="#总结感悟" class="headerlink" title="总结感悟"></a>总结感悟</h2><p>1.这次从搭建到发布到github上面大概只用了一两个小时，相比于之前用了很多个晚上都没有搭建起来，我觉得是我所参考的资料不一样的原因，这次用谷歌查到的资料，思路清晰，步骤详细，方法正确。<br>  推荐一个最近刚使用并且效果不错的翻墙工具：<a href="https:/getlantern.org/" target="_blank" rel="external">Lantern</a><br>2.可以通过别人的博客了解到一个东西，但是想真正使用掌握一个知识，个人认为还是看官方文档最受益</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简要说明&quot;&gt;&lt;a href=&quot;#简要说明&quot; class=&quot;headerlink&quot; title=&quot;简要说明&quot;&gt;&lt;/a&gt;简要说明&lt;/h2&gt;&lt;p&gt;本篇博客是记录自己怎么搭建起这个博客，以及过程中遇到什么问题，如何解决这些问题。&lt;/p&gt;
&lt;h2 id=&quot;了解Hexo&quot;&gt;&lt;
    
    </summary>
    
      <category term="2016年9月" scheme="https://xmhuster.github.io/MBlog/categories/2016%E5%B9%B49%E6%9C%88/"/>
    
    
      <category term="杂文" scheme="https://xmhuster.github.io/MBlog/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
</feed>
